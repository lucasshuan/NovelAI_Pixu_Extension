/*---
compatibilityVersion: naiscript-1.0
id: 781dc32b-fb21-424a-a691-46b353d3f195
name: Foxfire
createdAt: 1769472066066
updatedAt: 1769526612338
version: 0.1.0
author: Noble
memoryLimit: 8
---*/
type Entry = {
  id: string;
  sectionId: number;
  order: number;
};

const KEY_ENTRIES = "cg:entries"; // storyStorage: Entry[]
const PANEL_ID = "foxfire";

const PLACEHOLDER_IMAGE_BASE64 = "data:image/webp;base64,UklGRjwFAABXRUJQVlA4IDAFAACQPwCdASpoAWgBPpFIokslpKOhopXZWLASCWlu4XVQ+XuUUaXnR4/Ad1jWLcGbVLsBxdbyj+HgP/da02er8I5iVwgp6B4zSgp6B4+edGIHAqLtZUzSgp6B4zSgp6B4zSgp6B4zSgp6B4zSgp6B4zSgp6B4zSgp6B23i7sjN+jTrWp9GnWtT6NOtan0aXhMnktg0QR6QfmkiIC71/eMWdfYWel/YZJ9eaRBJM4FkII/d9Hubb2tAU9X/oMmfxre+cMbK8wAeHCgqjj79HCwE5vhFMNqLKmaC995Y/52jCDzNoEW5LwndlSAvOXwyDpSFBe+8sf87PtTTiHN22cViP6KvdGBdJy5YYgFkAILsrsZqoBS15KammKY6DuSq5vXW8eB4SepTbo4h4WDVHH5AwhP/0YKMD49MWGZIY6xldBdUT2qokXYxCxKCakKvfWdMhzN0oe+vbBC4l9CgBsOrKHxIgmMK0lrwPRdQtVfBltAWpyYA5lNA8a7C9Bh0tgvzjVu+jssRF3M4oq+L0kKx3pA4Lo+QJna+izVQClI0psgiM5p2VORVNgpRRsfgaiZyLOvrufPUCRVh/cBe5ugcF/aY6Gm/RenOC2Y6zmQoKUFPQPGaUFPQPGaUFPQPGaUFPQPGaUFPQPGaUFPQPGaUFPQPGaUFPQPGaUFPQPGaUFPQPGaUFMwAP7/amFWYsE4Gq3Ag5L9ALaALNAC9QAzON2EkZnFQiv1THhtyqi119HUw27MOssykSHZqGN5QJsmgmgmgm4CRG/wxAtX7+4k211Pa7psIklpWifqccoW8xSMU90KdfeW0cm7jymFIjAVSua7DJ3Q1UP5xqcAdMrlJ/NBQFqWdX5J/sV2B3kZx+wlnKfASE5bLANvCg8qhfZf+BlnCUP0c8psAd2p7ZktRBQQnNXMrCW3xe3hn3XnAHQ7/ZmwiHl+l1UfHIesKtjv26CbpY+bnt2xP5TEbCz1gU8AeXozczOjsZ6IrSZc/XKdWVrcqGiHKmbvu2KfpjpKs03Wv9kUWqA/cL3FwV+UaVG3+v2Vc8jHRrNyJbOtEzzdAHRhlT7s1c9aAqSH7yEqp37xqMDeR4YK7UNY8uyCCH344L0moTMTCp1LIU+u8K8S8NY4F64GBm49OoK6FGX1SoWQewTUPRWCfUkFnKeEio14jiAVObZN4rbi4Zr/43SzUdCrcjwjM68QTu+zwcjj0kweNOR04PzARtG4FPubbNcSkmOrn7ksOa5ACU2EQIHEvrm73GStEUgz95Wu8WPVPeoQqS0GbrJC9uHN1N21tYjP1L47OkYxY2Pe6PIAF4Len6zIUJhTnZ90hzZzJ+BkgHNaAOzLyefN+WpGstMFCc5JEZ3bpdQ5HdQOnuB6Kz2ATtrZhXJ0wDmgjhESD5nwgTmNwMSs8/ufVaHjW9k3F17yDBeOzEWkKm2+6CeI/q7rIvhW8b9S18XStYBKnu8fnqKNZG0It3L929o+7W12Hv+/E0mzGXNiYtrtdHpHpLNZhXJ0wDmgjhESD5nwgTmNwMSs8/ufW5ILTzbDGbISnDRoaQlu5wWf2UxvOuK2qFVEUa2+76plWzyZ0UQJZglcScZuskL27DMGw0SeSPtUw4CrAU+HhWsPjvtBdgtLnZIboM65rpiC5PwfYq0EGy783IGok8+atygPXHYAzqZM6fyuZ7+fl9/daf+C6LeJjsRZVWE81wpPTakEH7y7M79y2gzrSmysWdQYFe2xkufeOhQUADfYBCmAQpgEkcBSoAAAAA=="

function uid(): string {
  return Math.random().toString(36).slice(2, 10);
}

function keyOf(e: Pick<Entry, "sectionId" | "order">): string {
  return `${e.sectionId}:${e.order}`;
}

async function getEntries(): Promise<Entry[]> {
  const v = await api.v1.storyStorage.get(KEY_ENTRIES);
  return (v ?? []) as Entry[];
}

async function setEntries(entries: Entry[]): Promise<void> {
  await api.v1.storyStorage.set(KEY_ENTRIES, entries);
}

async function ensurePerms(): Promise<void> {
  await api.v1.permissions.request(
    ["editorDecorations", "fileInput", "documentEdit"],
    "Needed to place widgets in the editor and import images."
  );
}
function stableSlotKey(entry: Entry): string {
  return `${entry.sectionId}:${entry.order}:${entry.id}`;
}

function buildWidgetContent(entry: Entry, slotNumber: number): UIPart[] {
  const label = `Image Slot #${slotNumber}`;

  const headerRow = api.v1.ui.part.row({
    spacing: "space-between",
    content: [
      api.v1.ui.part.text({ text: label, style: { color: "textMain", opacity: 0.3 } }),
      api.v1.ui.part.button({
        iconId: "x",
        style: { backgroundColor: "bg2", height: 24, width: 24, padding: 0, display: "flex", justifyContent: "center", alignItems: "center" },
        callback: async () => {
          await removeEntry(entry.id);
        },
      }),
    ]
  })

  const slotKey = stableSlotKey(entry);

  const imageContainer = api.v1.ui.part.image({
    src: PLACEHOLDER_IMAGE_BASE64,
    height: 340,
    style: { objectFit: "contain" },
    id: `cg-img-${slotKey}`,
    alt: `Image #${slotKey}`,
  });

  return [
    api.v1.ui.part.box({
      style: { borderRadius: 10, padding: "6px 6px" },
      content: [
        api.v1.ui.part.column({
          spacing: "center",
          content: [
            headerRow,
            imageContainer,
          ],
        }),
      ]
    }),
  ];
}

async function rebuildAllWidgets(): Promise<void> {
  await ensurePerms();

  api.v1.editor.decorations.clearWidgets();

  const entries = await getEntries();

  const sections = await api.v1.document.scan();
  const sectionIndex = new Map<number, number>();
  for (let i = 0; i < sections.length; i++) {
    sectionIndex.set(sections[i].sectionId, i);
  }

  const ordered = await getOrderedEntries(entries);

  const widgetOpts = ordered.map((e, idx) => ({
    type: "node",
    sectionId: e.sectionId,
    side: "after",
    content: buildWidgetContent(e, idx + 1),
  } as DecorationCreateNodeWidgetOptions));

  await api.v1.editor.decorations.createWidgets(widgetOpts);
}

async function addImageHere(): Promise<void> {
  await ensurePerms();

  const selection = await api.v1.editor.selection.get();
  const sectionId: number | undefined = selection?.from?.sectionId;

  if (sectionId === undefined || sectionId === null) {
    api.v1.ui.toast("Couldn't detect the current section. Click inside the story text first.");
    return;
  }

  const entries = await getEntries();

  const inSection = entries.filter((e) => e.sectionId === sectionId);
  const nextOrder = inSection.length ? Math.max(...inSection.map((e) => e.order)) + 1 : 0;

  const next: Entry = { id: uid(), sectionId, order: nextOrder };

  await setEntries([...entries, next]);

  await rebuildAllWidgets();
}

async function clearEntries(): Promise<void> {
  await setEntries([]);
  api.v1.editor.decorations.clearWidgets();
  api.v1.ui.toast("Cleared saved image slots for this story.");
}

async function clearGallerySession(): Promise<void> {
  await rebuildAllWidgets();

  await renderPanel();

  api.v1.ui.toast("Cleared session-only gallery (images unloaded).");
}

async function removeEntry(entryId: string): Promise<void> {
  const entries = await getEntries();
  const entry = entries.find((e) => e.id === entryId);
  if (!entry) return;

  const nextEntries = entries.filter((e) => e.id !== entryId);
  await setEntries(nextEntries);

  await rebuildAllWidgets();
}

async function unloadSlotImage(entryId: string): Promise<void> {
  const entries = await getEntries();
  const entry = entries.find((e) => e.id === entryId);
  if (!entry) return;

  await rebuildAllWidgets();
}

async function getOrderedEntries(entries: Entry[]): Promise<Entry[]> {
  const sections = await api.v1.document.scan();
  const sectionIndex = new Map<number, number>();
  for (let i = 0; i < sections.length; i++) sectionIndex.set(sections[i].sectionId, i);

  return [...entries].sort((a, b) => {
    const ai = sectionIndex.get(a.sectionId) ?? Number.MAX_SAFE_INTEGER;
    const bi = sectionIndex.get(b.sectionId) ?? Number.MAX_SAFE_INTEGER;
    if (ai !== bi) return ai - bi;
    return a.order - b.order;
  });
}

async function renderPanel() {
  await api.v1.ui.register([
    api.v1.ui.extension.scriptPanel({
      id: PANEL_ID,
      name: "Image Slots",
      iconId: "image",
      content: [
        api.v1.ui.part.column({
          content: [
            api.v1.ui.part.row({
              wrap: true,
              spacing: "center",
              content: [
                api.v1.ui.part.button({ text: "Add Image Slot", iconId: "plus", callback: addImageHere }),
                api.v1.ui.part.button({ text: "Clear All Image Slots", iconId: "trash", callback: clearEntries, style: { color: "warning" } }),
              ],
            }),
          ],
        }),

      ],
    }),
  ]);
}

api.v1.hooks.register("onScriptsLoaded", async () => {
  await rebuildAllWidgets();
});

await renderPanel();
